AWSTemplateFormatVersion: "2010-09-09"
Description: >
  CodeBuild-only deployer that clones a GitHub repo via Deploy Key (SSH),
  resolves StackName and params.json filename based on template Metadata.StackName presence,
  and creates a CloudFormation Change Set (no execute).

Parameters:
  BuildProjectName:
    Type: String
    Default: cfn-changeset-deployer
    Description: CodeBuild project name.

  GithubSshRepo:
    Type: String
    Description: Git SSH URL (e.g., git@github.com:ORG/REPO.git)

  DeployKeySsmParamName:
    Type: String
    Default: /cfn-deployer/github/deploykey
    Description: SSM SecureString parameter name that stores the private deploy key.

  DefaultGitRef:
    Type: String
    Description: Git ref fixed for this build project (e.g., develop, main).

  TemplateBasePath:
    Type: String
    Default: shuppa-infrastracture/cfn/templates
    Description: >
      Base path inside the repo. At build start, provide TEMPLATE relative to this base
      OR provide a file name and it will be searched under this base.

  ProjectName:
    Type: String
    Default: mobile-sales
    Description: Project name used for naming and resolving !Sub ${ProjectName}-xxx.

  EnvironmentName:
    Type: String
    Default: dev
    Description: Environment name used when template has no Metadata.StackName.

Resources:
  CodeBuildLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/codebuild/${BuildProjectName}
      RetentionInDays: 30

  CodeBuildServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${BuildProjectName}-role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${BuildProjectName}-policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${BuildProjectName}:*

              - Effect: Allow
                Action:
                  - ssm:GetParameter
                Resource: !Sub arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter${DeployKeySsmParamName}

              - Effect: Allow
                Action:
                  - kms:Decrypt
                Resource: "*"

              - Effect: Allow
                Action:
                  - cloudformation:ValidateTemplate
                  - cloudformation:CreateChangeSet
                  - cloudformation:DescribeChangeSet
                  - cloudformation:DescribeStacks
                  - cloudformation:ListStacks
                Resource: "*"

  CodeBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Ref BuildProjectName
      ServiceRole: !GetAtt CodeBuildServiceRole.Arn
      Artifacts:
        Type: NO_ARTIFACTS

      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/standard:7.0
        PrivilegedMode: false
        EnvironmentVariables:
          - Name: AWS_DEFAULT_REGION
            Type: PLAINTEXT
            Value: !Ref AWS::Region
          - Name: DEPLOY_KEY_SSM_PARAM
            Type: PLAINTEXT
            Value: !Ref DeployKeySsmParamName
          - Name: GIT_SSH_REPO
            Type: PLAINTEXT
            Value: !Ref GithubSshRepo
          - Name: DEFAULT_GIT_REF
            Type: PLAINTEXT
            Value: !Ref DefaultGitRef
          - Name: TEMPLATE_BASE_PATH
            Type: PLAINTEXT
            Value: !Ref TemplateBasePath
          - Name: PROJECT_NAME
            Type: PLAINTEXT
            Value: !Ref ProjectName
          - Name: ENV
            Type: PLAINTEXT
            Value: !Ref EnvironmentName

          # Required at build start:
          - Name: TEMPLATE
            Type: PLAINTEXT
            Value: ""

      LogsConfig:
        CloudWatchLogs:
          Status: ENABLED
          GroupName: !Ref CodeBuildLogGroup
          StreamName: build-log

      Source:
        Type: NO_SOURCE
        BuildSpec: |
          version: 0.2

          phases:
            install:
              commands:
                - |
                  set -eu
                  if command -v yum >/dev/null 2>&1; then
                    yum -y install jq git
                  elif command -v dnf >/dev/null 2>&1; then
                    dnf -y install jq git
                  elif command -v apt-get >/dev/null 2>&1; then
                    export DEBIAN_FRONTEND=noninteractive
                    apt-get update -y
                    apt-get install -y jq git
                  else
                    echo "ERROR: No supported package manager found (yum/dnf/apt-get)."
                    exit 1
                  fi
                  git --version
                  jq --version
                  aws --version || true
                  bash --version | head -n 1 || true

            pre_build:
              commands:
                - |
                  bash -lc '
                    set -euo pipefail

                    : "${TEMPLATE:?TEMPLATE is required}"
                    : "${TEMPLATE_BASE_PATH:?TEMPLATE_BASE_PATH is required}"
                    : "${PROJECT_NAME:?PROJECT_NAME is required}"
                    : "${ENV:?ENV is required}"
                    : "${DEFAULT_GIT_REF:?DEFAULT_GIT_REF is required}"

                    echo "DEFAULT_GIT_REF=$DEFAULT_GIT_REF"
                    echo "TEMPLATE_BASE_PATH=$TEMPLATE_BASE_PATH"
                    echo "PROJECT_NAME=$PROJECT_NAME"
                    echo "ENV=$ENV"
                    echo "TEMPLATE=$TEMPLATE"

                    # ---- Configure SSH deploy key ----
                    mkdir -p ~/.ssh
                    aws ssm get-parameter --name "$DEPLOY_KEY_SSM_PARAM" --with-decryption --query "Parameter.Value" --output text > ~/.ssh/id_rsa
                    chmod 600 ~/.ssh/id_rsa
                    ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts
                    eval "$(ssh-agent -s)"
                    ssh-add ~/.ssh/id_rsa

                    # ---- Clone repo (fixed ref per project) ----
                    rm -rf repo
                    git clone --depth 1 --branch "$DEFAULT_GIT_REF" "$GIT_SSH_REPO" repo
                    cd repo

                    BASE_DIR="./${TEMPLATE_BASE_PATH#./}"
                    BASE_DIR="${BASE_DIR%/}"
                    TEMPLATE_INPUT="$TEMPLATE"

                    # ---- Resolve template file (path or find) ----
                    if [[ "$TEMPLATE_INPUT" == *"/"* ]]; then
                      REL="${TEMPLATE_INPUT#./}"
                      REL="${REL#/}"
                      TEMPLATE_FILE="$BASE_DIR/$REL"
                      [[ -f "$TEMPLATE_FILE" ]] || { echo "Template not found: $TEMPLATE_FILE"; exit 1; }
                    else
                      MATCHED_FILES="$(find "$BASE_DIR" -type f -name "$TEMPLATE_INPUT" -print)"
                      [[ -n "$MATCHED_FILES" ]] || { echo "Template not found: $TEMPLATE_INPUT"; exit 1; }
                      COUNT="$(printf "%s\n" "$MATCHED_FILES" | wc -l | tr -d " ")"
                      [[ "$COUNT" -le 1 ]] || { echo "Multiple templates found:"; echo "$MATCHED_FILES"; exit 1; }
                      TEMPLATE_FILE="$MATCHED_FILES"
                    fi

                    echo "TEMPLATE_FILE=$TEMPLATE_FILE"
                    TEMPLATE_DIR="$(dirname "$TEMPLATE_FILE")"
                    YAML_BASENAME="$(basename "$TEMPLATE_FILE")"
                    YAML_NAME="${YAML_BASENAME%.*}"   # alb.yaml -> alb

                    # ---- Read Metadata.StackName (1-line) if present ----
                    STACK_EXPR="$(python3 - <<PY
import re, sys
p=sys.argv[1]
lines=open(p,"r",encoding="utf-8").read().splitlines()
in_meta=False
meta_indent=None
expr=""
for raw in lines:
  line=raw.rstrip()
  if not line.strip() or line.lstrip().startswith("#"):
    continue
  if re.match(r"^\\s*Metadata\\s*:\\s*$", line):
    in_meta=True
    meta_indent=len(line)-len(line.lstrip(" "))
    continue
  if in_meta:
    indent=len(line)-len(line.lstrip(" "))
    if meta_indent is not None and indent <= meta_indent:
      in_meta=False
      continue
    m=re.match(r"^\\s*StackName\\s*:\\s*(.+?)\\s*$", line)
    if m:
      expr=m.group(1).strip()
      break
print(expr, end="")
PY
"$TEMPLATE_FILE")"

                    if [[ -n "$STACK_EXPR" ]]; then
                      # Case ①: Metadata.StackName exists -> use it (resolve !Sub with ${ProjectName})
                      if [[ "$STACK_EXPR" == \!Sub* ]]; then
                        STACK_EXPR="${STACK_EXPR#\!Sub}"
                        STACK_EXPR="${STACK_EXPR# }"
                      fi
                      # strip surrounding quotes
                      STACK_EXPR="${STACK_EXPR%\"}"; STACK_EXPR="${STACK_EXPR#\"}"
                      STACK_EXPR="${STACK_EXPR%\'}"; STACK_EXPR="${STACK_EXPR#\'}"

                      STACK_NAME="${STACK_EXPR//\$\{ProjectName\}/$PROJECT_NAME}"

                      if [[ "$STACK_NAME" == *"\${"* ]]; then
                        echo "ERROR: Unresolved variables in StackName expression:"
                        echo "  expr=$STACK_EXPR"
                        echo "  resolved=$STACK_NAME"
                        exit 1
                      fi

                      PARAMS_FILE="$TEMPLATE_DIR/$STACK_NAME.params.json"
                      echo "[Case①] STACK_NAME=$STACK_NAME"
                      echo "[Case①] PARAMS_FILE=$PARAMS_FILE"
                    else
                      # Case ②: No Metadata.StackName -> generate
                      STACK_NAME="${PROJECT_NAME}-${ENV}-${YAML_NAME}"
                      PARAMS_FILE="$TEMPLATE_DIR/${PROJECT_NAME}-${ENV}-${YAML_NAME}.params.json"
                      echo "[Case②] STACK_NAME=$STACK_NAME"
                      echo "[Case②] PARAMS_FILE=$PARAMS_FILE"
                    fi

                    [[ -f "$PARAMS_FILE" ]] || { echo "Parameters file not found: $PARAMS_FILE"; exit 1; }

                    CHANGESET_NAME="${STACK_NAME}-cs-$(date +%Y%m%d%H%M%S)"
                    echo "CHANGESET_NAME=$CHANGESET_NAME"

                    {
                      echo "export TEMPLATE_FILE=\"$TEMPLATE_FILE\""
                      echo "export STACK_NAME=\"$STACK_NAME\""
                      echo "export PARAMS_FILE=\"$PARAMS_FILE\""
                      echo "export CHANGESET_NAME=\"$CHANGESET_NAME\""
                    } > /tmp/cfn_vars.sh
                  '

            build:
              commands:
                - |
                  bash -lc '
                    set -euo pipefail
                    . /tmp/cfn_vars.sh

                    aws cloudformation validate-template --template-body "file://$TEMPLATE_FILE"

                    if aws cloudformation describe-stacks --stack-name "$STACK_NAME" >/dev/null 2>&1; then
                      CHANGESET_TYPE="UPDATE"
                    else
                      CHANGESET_TYPE="CREATE"
                    fi
                    echo "CHANGESET_TYPE=$CHANGESET_TYPE"

                    # params.json is expected to be CloudFormation CLI format:
                    # [ { "ParameterKey": "...", "ParameterValue": "..." }, ... ]
                    aws cloudformation create-change-set \
                      --stack-name "$STACK_NAME" \
                      --template-body "file://$TEMPLATE_FILE" \
                      --change-set-name "$CHANGESET_NAME" \
                      --change-set-type "$CHANGESET_TYPE" \
                      --parameters "file://$PARAMS_FILE" \
                      --capabilities CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND

                    aws cloudformation wait change-set-create-complete --stack-name "$STACK_NAME" --change-set-name "$CHANGESET_NAME"
                    aws cloudformation describe-change-set --stack-name "$STACK_NAME" --change-set-name "$CHANGESET_NAME"

                    echo "DONE: Change Set created (not executed)."
                  '

Outputs:
  CodeBuildProjectName:
    Value: !Ref BuildProjectName
  CodeBuildRoleArn:
    Value: !GetAtt CodeBuildServiceRole.Arn
  LogGroupName:
    Value: !Ref CodeBuildLogGroup
