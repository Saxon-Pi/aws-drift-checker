AWSTemplateFormatVersion: "2010-09-09"
Description: >
  CodeBuild-only CloudFormation ChangeSet creator.
  Clones GitHub via Deploy Key (SSH) from SSM SecureString, resolves stack/params automatically, creates ChangeSet (no execute).

Parameters:
  CodeBuildProjectName:
    Type: String
    Default: mobile-sales-dev-cfn-changeset-deployer
    Description: CodeBuild project name (unique in account/region).

  GithubSshRepo:
    Type: String
    Description: Git SSH URL (e.g., git@github.com:ORG/REPO.git)

  GitRef:
    Type: String
    Description: Git branch/tag to checkout (fixed for this environment project).

  DeployKeySsmParamName:
    Type: String
    Default: /cfn-deployer/github/deploykey
    Description: SSM SecureString parameter name that stores the private deploy key.

  TemplateBasePath:
    Type: String
    Default: cfn/templates
    Description: Base directory in the repo where templates exist (repo root relative).

  ProjectName:
    Type: String
    Default: mobile-sales
    Description: ProjectName used for StackName resolution (replaces ${ProjectName}).

  EnvName:
    Type: String
    Default: dev
    AllowedValues: [dev, stg, stg2, product]
    Description: Environment name used when Metadata.StackName is missing.

Resources:
  CodeBuildLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/codebuild/${CodeBuildProjectName}
      RetentionInDays: 30

  CodeBuildServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${CodeBuildProjectName}-role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${CodeBuildProjectName}-policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/${CodeBuildProjectName}:*

              - Effect: Allow
                Action:
                  - ssm:GetParameter
                Resource: !Sub arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter${DeployKeySsmParamName}

              - Effect: Allow
                Action:
                  - kms:Decrypt
                Resource: "*"

              - Effect: Allow
                Action:
                  - cloudformation:ValidateTemplate
                  - cloudformation:CreateChangeSet
                  - cloudformation:DescribeChangeSet
                  - cloudformation:ListChangeSets
                  - cloudformation:DescribeStacks
                  - cloudformation:DescribeStackEvents
                  - cloudformation:ListStacks
                Resource: "*"

  CodeBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Ref CodeBuildProjectName
      ServiceRole: !GetAtt CodeBuildServiceRole.Arn
      Artifacts:
        Type: NO_ARTIFACTS

      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/standard:7.0
        PrivilegedMode: false
        EnvironmentVariables:
          - Name: AWS_DEFAULT_REGION
            Type: PLAINTEXT
            Value: !Ref AWS::Region
          - Name: GIT_SSH_REPO
            Type: PLAINTEXT
            Value: !Ref GithubSshRepo
          - Name: GIT_REF
            Type: PLAINTEXT
            Value: !Ref GitRef
          - Name: DEPLOY_KEY_SSM_PARAM
            Type: PLAINTEXT
            Value: !Ref DeployKeySsmParamName
          - Name: TEMPLATE_BASE_PATH
            Type: PLAINTEXT
            Value: !Ref TemplateBasePath
          - Name: PROJECT_NAME
            Type: PLAINTEXT
            Value: !Ref ProjectName
          - Name: ENV
            Type: PLAINTEXT
            Value: !Ref EnvName

          # Required at build start:
          - Name: TEMPLATE
            Type: PLAINTEXT
            Value: ""

      LogsConfig:
        CloudWatchLogs:
          Status: ENABLED
          GroupName: !Ref CodeBuildLogGroup
          StreamName: build-log

      Source:
        Type: NO_SOURCE
        # ★ ここが重要：!Sub を使わない
        BuildSpec: |
          version: 0.2

          phases:
            install:
              commands:
                - |
                  set -eu
                  if command -v apt-get >/dev/null 2>&1; then
                    export DEBIAN_FRONTEND=noninteractive
                    apt-get update -y
                    apt-get install -y jq git
                  elif command -v yum >/dev/null 2>&1; then
                    yum -y install jq git
                  elif command -v dnf >/dev/null 2>&1; then
                    dnf -y install jq git
                  else
                    echo "ERROR: No supported package manager found (apt-get/yum/dnf)."
                    exit 1
                  fi
                  aws --version
                  git --version
                  jq --version

            pre_build:
              commands:
                - |
                  set -eu

                  if [ -z "${TEMPLATE:-}" ]; then
                    echo "ERROR: TEMPLATE is required."
                    echo "Example: TEMPLATE=all/alb/alb.yaml"
                    exit 1
                  fi

                  echo "GIT_REF=$GIT_REF"
                  echo "TEMPLATE_BASE_PATH=$TEMPLATE_BASE_PATH"
                  echo "PROJECT_NAME=$PROJECT_NAME"
                  echo "ENV=$ENV"
                  echo "TEMPLATE=$TEMPLATE"

                  # --- SSH deploy key from SSM ---
                  mkdir -p ~/.ssh
                  aws ssm get-parameter --name "$DEPLOY_KEY_SSM_PARAM" --with-decryption --query "Parameter.Value" --output text > ~/.ssh/id_rsa
                  chmod 600 ~/.ssh/id_rsa
                  ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts
                  eval "$(ssh-agent -s)"
                  ssh-add ~/.ssh/id_rsa

                  # --- clone repo ---
                  rm -rf repo
                  echo "Cloning: $GIT_SSH_REPO (ref: $GIT_REF)"
                  git clone --depth 1 --branch "$GIT_REF" "$GIT_SSH_REPO" repo
                  cd repo

                  BASE_DIR="./${TEMPLATE_BASE_PATH#./}"
                  BASE_DIR="${BASE_DIR%/}"
                  if [ ! -d "$BASE_DIR" ]; then
                    echo "ERROR: base dir not found in repo: $BASE_DIR"
                    echo "DEBUG repo root:"
                    ls -la
                    exit 1
                  fi
                  echo "BASE_DIR=$BASE_DIR"

                  TEMPLATE_INPUT="$TEMPLATE"
                  if echo "$TEMPLATE_INPUT" | grep -q "/"; then
                    REL="${TEMPLATE_INPUT#./}"
                    REL="${REL#/}"
                    TEMPLATE_FILE="$BASE_DIR/$REL"
                    if [ ! -f "$TEMPLATE_FILE" ]; then
                      echo "ERROR: Template not found: $TEMPLATE_FILE"
                      exit 1
                    fi
                  else
                    MATCHED_FILES="$(find "$BASE_DIR" -type f -name "$TEMPLATE_INPUT" -print)"
                    if [ -z "$MATCHED_FILES" ]; then
                      echo "ERROR: Template not found by name: $TEMPLATE_INPUT"
                      exit 1
                    fi
                    COUNT="$(printf "%s\n" "$MATCHED_FILES" | wc -l | tr -d " ")"
                    if [ "$COUNT" -gt 1 ]; then
                      echo "ERROR: Multiple templates found for $TEMPLATE_INPUT:"
                      echo "$MATCHED_FILES"
                      exit 1
                    fi
                    TEMPLATE_FILE="$MATCHED_FILES"
                  fi

                  TEMPLATE_DIR="$(dirname "$TEMPLATE_FILE")"
                  YAML_BASENAME="$(basename "$TEMPLATE_FILE")"
                  YAML_NAME="${YAML_BASENAME%.*}"

                  echo "TEMPLATE_FILE=$TEMPLATE_FILE"
                  echo "TEMPLATE_DIR=$TEMPLATE_DIR"
                  echo "YAML_NAME=$YAML_NAME"

                  STACK_EXPR="$(awk '
                    function indent(s){ match(s,/[^ ]/); return (RSTART?RSTART-1:0) }
                    BEGIN{inmeta=0; metaind=-1}
                    /^[[:space:]]*Metadata:[[:space:]]*$/ { inmeta=1; metaind=indent($0); next }
                    {
                      if(inmeta){
                        i=indent($0)
                        if(i<=metaind){ inmeta=0; next }
                        if($0 ~ /^[[:space:]]*StackName:[[:space:]]*/){
                          sub(/^[[:space:]]*StackName:[[:space:]]*/,"",$0)
                          print $0
                          exit
                        }
                      }
                    }
                  ' "$TEMPLATE_FILE")"

                  if [ -n "$STACK_EXPR" ]; then
                    case "$STACK_EXPR" in
                      "!Sub "* ) STACK_EXPR="${STACK_EXPR#\!Sub }" ;;
                      "!Sub" ) STACK_EXPR="" ;;
                      \!Sub* ) STACK_EXPR="${STACK_EXPR#\!Sub}" ; STACK_EXPR="${STACK_EXPR# }" ;;
                    esac
                    STACK_EXPR="${STACK_EXPR%\"}"; STACK_EXPR="${STACK_EXPR#\"}"
                    STACK_EXPR="${STACK_EXPR%\'}"; STACK_EXPR="${STACK_EXPR#\'}"

                    STACK_NAME="${STACK_EXPR//\$\{ProjectName\}/$PROJECT_NAME}"

                    if echo "$STACK_NAME" | grep -q '\${'; then
                      echo "ERROR: Unresolved variables remain in StackName:"
                      echo "  expr=$STACK_EXPR"
                      echo "  resolved=$STACK_NAME"
                      exit 1
                    fi

                    PARAMS_FILE="$TEMPLATE_DIR/$STACK_NAME.params.json"
                    echo "[Case1] STACK_NAME=$STACK_NAME"
                    echo "[Case1] PARAMS_FILE=$PARAMS_FILE"
                  else
                    STACK_NAME="$PROJECT_NAME-$ENV-$YAML_NAME"
                    PARAMS_FILE="$TEMPLATE_DIR/$PROJECT_NAME-$ENV-$YAML_NAME.params.json"
                    echo "[Case2] STACK_NAME=$STACK_NAME"
                    echo "[Case2] PARAMS_FILE=$PARAMS_FILE"
                  fi

                  if [ ! -f "$PARAMS_FILE" ]; then
                    echo "ERROR: Parameters file not found: $PARAMS_FILE"
                    echo "DEBUG template dir listing:"
                    ls -la "$TEMPLATE_DIR" || true
                    exit 1
                  fi

                  CHANGESET_NAME="$STACK_NAME-cs-$(date +%Y%m%d%H%M%S)"
                  echo "CHANGESET_NAME=$CHANGESET_NAME"

                  PARAMS_KIND="$(jq -r 'type' "$PARAMS_FILE")"
                  if [ "$PARAMS_KIND" = "array" ]; then
                    if jq -e 'all(.[]; has("ParameterKey") and has("ParameterValue"))' "$PARAMS_FILE" >/dev/null 2>&1; then
                      cp "$PARAMS_FILE" /tmp/params.cfn.json
                    else
                      echo "ERROR: params array must contain objects with ParameterKey and ParameterValue."
                      echo "  file=$PARAMS_FILE"
                      exit 1
                    fi
                  elif [ "$PARAMS_KIND" = "object" ]; then
                    jq -c 'to_entries|map({ParameterKey:.key,ParameterValue:(.value|tostring)})' "$PARAMS_FILE" > /tmp/params.cfn.json
                  else
                    echo "ERROR: Unsupported params JSON type: $PARAMS_KIND"
                    echo "  file=$PARAMS_FILE"
                    exit 1
                  fi

                  echo "PARAMS (normalized) => /tmp/params.cfn.json"
                  cat /tmp/params.cfn.json

                  {
                    echo "export REPO_DIR=$(pwd)"
                    echo "export TEMPLATE_FILE=$TEMPLATE_FILE"
                    echo "export STACK_NAME=$STACK_NAME"
                    echo "export CHANGESET_NAME=$CHANGESET_NAME"
                  } > /tmp/cfn_vars.sh

            build:
              commands:
                - |
                  set -eu
                  . /tmp/cfn_vars.sh

                  echo "EFFECTIVE:"
                  echo "  TEMPLATE_FILE=$TEMPLATE_FILE"
                  echo "  STACK_NAME=$STACK_NAME"
                  echo "  CHANGESET_NAME=$CHANGESET_NAME"

                  aws cloudformation validate-template --template-body "file://$TEMPLATE_FILE"

                  if aws cloudformation describe-stacks --stack-name "$STACK_NAME" >/dev/null 2>&1; then
                    CHANGESET_TYPE="UPDATE"
                  else
                    CHANGESET_TYPE="CREATE"
                  fi
                  echo "CHANGESET_TYPE=$CHANGESET_TYPE"

                  aws cloudformation create-change-set \
                    --stack-name "$STACK_NAME" \
                    --template-body "file://$TEMPLATE_FILE" \
                    --change-set-name "$CHANGESET_NAME" \
                    --change-set-type "$CHANGESET_TYPE" \
                    --parameters "file:///tmp/params.cfn.json" \
                    --capabilities CAPABILITY_NAMED_IAM CAPABILITY_AUTO_EXPAND

                  # Wait. If it fails, check reason. "no changes" should be treated as success.
                  if ! aws cloudformation wait change-set-create-complete \
                    --stack-name "$STACK_NAME" \
                    --change-set-name "$CHANGESET_NAME"
                  then
                    echo "ChangeSet wait FAILED. Describing change set..."
                    aws cloudformation describe-change-set \
                      --stack-name "$STACK_NAME" \
                      --change-set-name "$CHANGESET_NAME" \
                      --output json || true

                    REASON="$(aws cloudformation describe-change-set \
                      --stack-name "$STACK_NAME" \
                      --change-set-name "$CHANGESET_NAME" \
                      --query 'StatusReason' \
                      --output text 2>/dev/null || true)"

                    echo "StatusReason=$REASON"

                    # Treat "no changes" as success
                    echo "$REASON" | grep -Eqi "didn't contain changes|No updates are to be performed|The submitted information didn't contain changes" && {
                      echo "No changes detected. Treating as SUCCESS."
                      exit 0
                    }

                    echo "ChangeSet failed for a real reason. Marking build as FAILED."
                    exit 1
                  fi

                  echo "ChangeSet created (not executed). Summary:"
                  aws cloudformation describe-change-set \
                    --stack-name "$STACK_NAME" \
                    --change-set-name "$CHANGESET_NAME" \
                    --query '{Status:Status,ExecutionStatus:ExecutionStatus,StatusReason:StatusReason}' \
                    --output json

                  echo "List ChangeSets:"
                  aws cloudformation list-change-sets --stack-name "$STACK_NAME" --output table || true

Outputs:
  CodeBuildProjectName:
    Value: !Ref CodeBuildProjectName
  CodeBuildRoleArn:
    Value: !GetAtt CodeBuildServiceRole.Arn
  LogGroupName:
    Value: !Ref CodeBuildLogGroup
